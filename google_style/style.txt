函数参数列表中, 所有引用参数都必须是 const:
void Foo(const string &in, string *out);

只在定义移动构造函数与移动赋值操作时使用右值引用, 不要使用 std::forward 功能函数. 
你可能会使用 std::move 来表示将值从一个对象移动而不是复制到另一个对象.

如果您打算重载一个函数, 可以试试改在函数名里加上参数信息。例如，用 AppendString() 和 AppendInt() 等， 
而不是一口气重载多个 Append().因为当派生类只重载了某个函数的部分变体，继承语义容易令人困惑。

我们不允许使用缺省函数参数，少数极端情况除外。尽可能改用函数重载。
缺省参数会干扰函数指针，害得后者的函数签名（function signature）往往对不上所实际要调用的函数签名。即在一个现有函数添加缺省参数，就会改变它的类
此外把自带缺省参数的函数地址赋值给指针时，会丢失缺省参数信息
只允许在非虚函数中使用缺省参数, 且必须保证缺省参数的值始终一致
缺省参数是在每个调用点都要进行重新求值的, 这会造成生成的代码迅速膨胀
以下情况允许：
    静态函数或匿名空间函数，毕竟都只能在局部文件里调用该函数
    在构造函数里用缺省参数，毕竟不可能取得它们的地址
    用来模拟变长数组

不允许使用变长数组和 alloca() 不是标准 C++ 的组成部分. 它们根据数据大小动态分配堆栈内存, 会引起难以发现的内存越界 bugs
改用更安全的分配器（allocator），就像 std::vector 或 std::unique_ptr<T[]>.

友元扩大了 (但没有打破) 类的封装边界. 某些情况下, 相对于将类成员声明为 public, 使用友元是更好的选择

通常我们 禁止使用多重继承, 但在使用 COM 和 ATL/WTL 类时可以使用多重继承. 为了实现 COM 或 ATL/WTL 类/接口, 你可能不得不使用多重实现继承.

构造失败时只有异常可以处理, Google 禁止使用异常这一点, 仅仅是为了自身的方便, 说大了, 无非是基于软件管理成本上, 实际使用中还是自己决定

RTTI 允许程序员在运行时识别 C++ 类对象的类型. 它通过使用 typeid 或者 dynamic_cast 完成.
Derived* that = dynamic_cast<Derived*>(other);
  if (that == NULL) return false;
在单元测试中可以使用 RTTI, 但是在其他代码中请尽量避免. 尤其是在新代码中, 使用 RTTI 前务必三思
基于类型的判断树是一个很强的暗示, 它说明你的代码已经偏离正轨了
不要去手工实现一个类似 RTTI 的方案. 反对 RTTI 的理由同样适用于这些方案, 比如带类型标签的类继承体系. 
虚函数可以根据子类类型的不同而执行不同代码. 这是把工作交给了对象本身去处理.
如果这一工作需要在对象之外完成, 可以考虑使用双重分发的方案, 例如使用访问者设计模式


用 static_cast 替代 C 风格的值转换, 或某个类指针需要明确的向上转换为父类指针时.
用 const_cast 去掉 const 限定符.
用 reinterpret_cast 指针类型和整型或其它指针之间进行不安全的相互转换. 仅在你对所做一切了然于心时使用.

对简单数值 (非对象), 两种都无所谓. 对迭代器和模板类型, 使用前置自增 (自减).
前置自增 (++i) 通常要比后置自增 (i++) 效率更高.


强烈建议你在任何可能的情况下都要使用 const


使用断言来指出变量为非负数, 而不是使用无符号型
<stdint.h> 定义了 int16_t, uint32_t, int64_t 等整型, 在需要确保整型大小时可以使用它们代替 short, unsigned long long 等. 在 C 整型中, 
只使用 int. 在合适的情况下, 推荐使用标准类型如 size_t 和 ptrdiff_t.
不要使用 uint32_t 等无符号整型, 除非你是在表示一个位组而不是一个数值, 或是你需要定义二进制补码溢出

尽可能用 sizeof(varname) 代替 sizeof(type).

用 auto 绕过烦琐的类型名，只要可读性好就继续用，别用在局部变量之外的地方。
auto 只能用在局部变量里用。别用在文件作用域变量，命名空间作用域变量和类数据成员里。永远别列表初始化 auto 变量。

适当使用 lambda 表达式。别用默认 lambda 捕获，所有捕获都要显式写出来。
如果可读性更好，就显式写出 lambd 的尾置返回类型，就像auto.

不要使用复杂的模板编程


不要定义隐式类型转换. 对于转换运算符和单参数构造函数, 请使用 explicit 关键字.
拷贝和移动构造函数不应当被标记为 explicit, 因为它们并不执行类型转换

MyClass(const MyClass&) = delete;
MyClass& operator=(const MyClass&) = delete;

仅当只有数据成员时使用 struct, 其它一概使用 class.

所有继承必须是 public 的. 如果你想使用私有继承, 你应该替换成把基类的实例作为成员对象的方式.
不要过度使用实现继承. 组合常常更合适一些.

只有当所有父类除第一个外都是 纯接口类 时, 才允许使用多重继承. 为确保它们是纯接口, 这些类必须以 Interface 为后缀.

当一个类满足以下要求时, 称之为纯接口:
    只有纯虚函数 (”=0”) 和静态函数 (除了下文提到的析构函数).
    没有非静态数据成员.
    没有定义任何构造函数. 如果有, 也不能带有参数, 并且必须为 protected.
    如果它是一个子类, 也只能从满足上述条件并以 Interface 为后缀的类继承.

除少数特定环境外, 不要重载运算符. 也不要创建用户定义字面量.

将 所有 数据成员声明为 private, 除非是 static const 类型成员 

将相似的声明放在一起, 将 public 部分放在最前.
类定义一般应以 public: 开始, 后跟 protected:, 最后是 private:


